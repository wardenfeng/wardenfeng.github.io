# 分析深度图渲染【away3d】

![](http://images.feng3d.me/wordpress/wp-content/uploads/2015/07/20150704190309.png)

渲染代码见 分析阴影渲染【away3d】

若要显示深度图需做以下两点修改

away3d.core.render.RendererBase.executeRender

![](http://images.feng3d.me/wordpress/wp-content/uploads/2015/07/20150704190911.png)

away3d.core.render.DefaultRenderer.executeRender

![](http://images.feng3d.me/wordpress/wp-content/uploads/2015/07/20150704191043.png)

分析渲染代码

```
Compiling AGAL Code:
--------------------
mov vt0, va0								//va0:顶点坐标数据
m44 vt1, vt0, vc0							//vc0：模型空间->投影空间 变换矩阵
mov op, vt1									//输出投影坐标
mov v0, vt1									//传递投影坐标 到 片段着色器   v0:投影坐标
 
 
vc0:模型空间到投影空间 变换矩阵
[0]	2.5422259932383895E-4	
[1]	-4.0095168515108526E-4	
[2]	-8.259221795015037E-5	
[3]	0	
[4]	-1.9902504991287095E-11	
[5]	0.0010390059323981404	
[6]	-3.2926971471169963E-5	
[7]	0	
[8]	0.0013975199544802308	
[9]	7.293705857591704E-5	
[10]	1.5024338608782273E-5	
[11]	0	
[12]	-0.39874252676963806	
[13]	-0.06505756080150604	
[14]	0.9066528081893921	
[15]	1	
va0：顶点坐标
 
v0:投影后的顶点坐标
 
--------------------
div ft2, v0, v0.w									//计算深度值depth属于（0,1）,该范围外的将会被frc处理为0或1
mul ft0, fc0, ft2.z									//fc0(1,255,255*255,255*255*255)			//深度值保存为颜色值
frc ft0, ft0										//和上行代码配合，保存了深度的1/255/255/255的精度的值
mul ft1, ft0.yzww, fc1								//fc1(1/255,1/255,1/255,0)					//计算多余的值
sub oc, ft0, ft1									//真正的深度值 = 减去多余的(1/255)值  （精度在1/255/255/255）
 
 
//想办法低损耗保存深度值
 
fc0,fc1:
[0]	1	
[1]	255 [0xff]	
[2]	65025 [0xfe01]	
[3]	16581375 [0xfd02ff]	
[4]	0.00392156862745098	
[5]	0.00392156862745098	
[6]	0.00392156862745098	
[7]	0	
 
 
片段着色器计算貌似有些高深。。,
其目的是使用rgba高精度方式保存深度值，并且可以从rgba中获取深度值。
此处应把深度看为255进制数据，rgba分别保存4个位(1，1/255，1/255/255,1/255/255/255)的值。
此处使用rgba分别保存（1，1/255,1/255/255,1/255/255/255）这4个不同精度的值
depth = r*1 + g/255 + b/255/255 + a/255/255/255 + x；此处有depth,r,g,b,a属于(0,1)范围;地处x<1/255/255/255,x可忽略不计
 
正常计算rgba的方法
r=frc(depth)-frc(depth*255)/255;
g=frc(depth*255)-frc(depth*255*255)/255;
b=frc(depth*255*255)-frc(depth*255*255)/255;
a=frc(depth*255*255*255)-frc(depth*255*255*255*255)/255;
由于无法生成depth*255*255*255*255的值，精度就定在1/255/255/255，精度只会在1/255/255/255出有损失
因此 a= frc(depth*255*255*255)
 
 
通过渲染程序推倒
mul ft0, fc0, ft2.z => depth*(1,255,255*255,255*255*255)=(depth,depth*255,depth*255*255,depth*255*255*255)
frc ft0, ft0		=> (frc(depth),frc(depth*255),frc(depth*255*255),frc(depth*255*255*255)) 
mul ft1, ft0.yzww, fc1	=>	(frc(depth*255)/255,frc(depth*255*255)/255,frc(depth*255*255*255)/255,0)
sub oc, ft0, ft1		=>	(frc(depth)-frc(depth*255)/255,frc(depth*255)-frc(depth*255*255)/255,frc(depth*255*255)-frc(depth*255*255*255)/255,frc(depth*255*255*255))
						=>	(r,g,b,a)
```

